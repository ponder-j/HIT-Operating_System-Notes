# 🖨️ 操作系统第10章：I/O管理和磁盘调度 (I/O Management & Disk Scheduling)

## 🌟 核心逻辑：管理“杂乱”的设备

I/O 设备也是稀缺资源，而且**速度差异极大**。

- **主要矛盾**：CPU 的速度是纳秒级，硬盘是毫秒级，键盘是秒级。如果 CPU 傻傻等着设备传数据，系统就废了。
- **解决思路**：
  1. **层次化**：屏蔽底层细节，给上层提供统一接口。
  2. **缓冲 (Buffering)**：用内存做“蓄水池”，平滑速度差异。
  3. **调度 (Scheduling)**：给这一堆杂乱的请求排个序，让磁头少跑冤枉路。

## 第一部分：I/O 设备的分类与组织

*对应课件 Page 3-5*

### 1. 设备分类

- **人机交互类 (Human readable)**：慢。如打印机、键盘、鼠标。
- **机器交互类 (Machine readable)**：快。如磁盘、USB、传感器。
- **通信类 (Communication)**：如网卡。

### 2. I/O 功能的演进 (Evolution)

- **程序控制 I/O** (CPU 忙等) -> **中断驱动 I/O** (CPU 被打断) -> **DMA** (直接内存访问，CPU 解放) -> **I/O 通道** (有独立处理器的超级 DMA)。
- **趋势**：CPU 越来越不想管 I/O 的琐事，把任务下放给专用的 I/O 处理器。

### 3. I/O 软件设计目标

- **效率 (Efficiency)**：这是 I/O 这一章的核心（因为 I/O 往往是系统的瓶颈）。
- **通用性 (Generality)**：想办法用统一的指令（比如 `read()`, `write()`）去操作所有设备，不管是硬盘还是网卡。这叫**设备独立性**。

## 第二部分：I/O 缓冲技术 (I/O Buffering)

*对应课件 Page 20-30左右（根据大纲推断）*

为什么要有 Buffer？

为了平滑 CPU 和 I/O 设备之间的速度差异，把 I/O 操作和进程的执行解耦 (Decouple)。

### 1. 单缓冲 (Single Buffer)

- **原理**：在系统内存中切一块地做缓冲区。OS 此时可以**预读 (Read ahead)** 下一块数据。
- **效果**：计算和输入可以并行。
- **公式**：处理一块数据的时间 $T = \max(C, T)$。 （$C$: 计算时间，$T$: 输入时间）。

### 2. 双缓冲 (Double Buffer) / 缓冲交换 (Flip-Flop)

- **原理**：分配两个缓冲区。
- **过程**：I/O 填满 Buffer A 时，CPU 读 Buffer B；然后交换。
- **效果**：可以连续处理，不会被卡顿。

### 3. 循环缓冲 (Circular Buffer)

- **原理**：如果有多个缓冲区连成环。
- **适用**：用于 I/O 操作爆发式增长（Bursty traffic）的场景。

## 第三部分：磁盘调度 (Disk Scheduling) 🔥🔥🔥 必考计算题

*对应课件 Page 31-35*

这是本章的灵魂。所有的算法都是为了**减少寻道时间 (Seek Time)**，因为机械硬盘的磁头移动太慢了。

### 1. 磁盘性能参数 (Performance Parameters)

- **寻道时间 (Seek Time)**：磁头移动到指定磁道（柱面）的时间。**最耗时，也是调度算法唯一能优化的**。
- **旋转延迟 (Rotational Delay)**：扇区转到磁头底下的时间。
- **传输时间 (Transfer Time)**：数据读写的时间。
- **总时间** = 寻道 + 旋转 + 传输。

### 2. 调度算法详解 (Scheduling Policies)

#### A. 先进先出 (FIFO)

- **规则**：按请求到达的顺序处理。
- **评价**：**最公平**，但**性能最差**（磁头可能在磁盘两端乱跳）。

#### B. 最短寻道时间优先 (SSTF - Shortest Service Time First)

- **规则**：谁离我当前磁头位置最近，我先去谁那。
- **评价**：**吞吐量高**，但有**饥饿 (Starvation)** 风险（如果一直有附近的请求插队，边缘的请求永远处理不到）。

#### C. 扫描算法 (SCAN / Elevator Algorithm) —— 电梯算法

- **规则**：磁头只能**单方向**移动（比如从外向里），一路扫过去，把路上的请求都处理了；到了尽头（或者到了最后一个请求），**掉头**往回扫。
- **评价**：**消除了饥饿**，非常稳定。
- **缺点**：对两端的请求不太公平（刚扫过去就要等好久才能回来）。

#### D. 循环扫描 (C-SCAN / Circular SCAN)

- **规则**：磁头**只在一个方向**上干活（比如从里向外）。扫到头后，**立刻快速返回**起点（返回途中不干活），重新开始。
- **评价**：**请求等待时间更均匀**（就像单向循环巴士）。

#### E. N-step-SCAN & FSCAN

- **原理**：为了防止磁头被“粘”在某处（如果一堆请求都在同一个磁道狂轰滥炸，SSTF 和 SCAN 都会停在那不走）。这俩算法把请求**分组**处理，不再允许无限插队。

## 📝 必背英文术语表 (Exam Vocabulary)

| **英文**                       | **中文**         | **含义**             |
| ------------------------------ | ---------------- | -------------------- |
| **Seek Time**                  | 寻道时间         | 磁头找磁道，最慢     |
| **Rotational Latency**         | 旋转延迟         | 等扇区转过来         |
| **Direct Memory Access (DMA)** | 直接内存访问     | 不用CPU搬数据的技术  |
| **Buffering**                  | 缓冲             | 平滑速度差异         |
| **SSTF**                       | 最短寻道时间优先 | 贪心算法，可能有饥饿 |
| **SCAN**                       | 扫描/电梯算法    | 来回扫，无饥饿       |
| **C-SCAN**                     | 循环扫描         | 单向扫，更均匀       |
| **Disk Arm**                   | 磁臂             | 读写头所在的机械臂   |

## 💡 计算题解题模版 (Cheat Sheet)

题目：当前磁头在 100 号磁道。

请求序列：55, 58, 39, 18, 90, 160, 150, 38, 184。

问：SCAN 算法（向磁道号增加方向移动）的移动总距离？

**解题步骤**：

1. **排序**：先把请求从小到大排好：18, 38, 39, 55, 58, 90, 150, 160, 184。
2. **确定起点和方向**：起点 100，方向 -> 大。
3. **第一阶段（向右扫）**：
   - 100 -> 150 -> 160 -> 184。
   - （注意：如果题目说由 0-200 磁道组成，SCAN 可能会碰到边缘 200 才回头；如果没说，通常是碰到最后一个请求 184 就回头，这也叫 LOOK 算法。**考试通常默认碰到请求就回头，除非特别说明要碰墙**）。
4. **第二阶段（掉头向左扫）**：
   - 184 -> 90 -> 58 -> 55 -> 39 -> 38 -> 18。
5. **计算距离**：
   - 第一段：$184 - 100 = 84$
   - 第二段：$184 - 18 = 166$
   - 总距离：$84 + 166 = 250$

**易错点**：

- **SCAN vs C-SCAN**：C-SCAN 到了尽头是**不干活直接飞回起点**的。算距离时，这段“飞回”的距离也要算进去，但“飞回”途中经过的请求**不处理**！
- **SSTF 陷阱**：SSTF 容易陷入局部最优。做题时每走一步都要重新算一下左右两边谁最近，不要凭直觉画图。
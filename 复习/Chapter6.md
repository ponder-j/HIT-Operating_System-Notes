# ☠️ 操作系统第6章：死锁和饥饿 (Deadlock and Starvation)

## 🌟 核心逻辑：锁出来的祸

为了解决竞争条件，我们引入了互斥锁。但如果有两个进程 A 和 B：

- A 拿了资源 1，等着资源 2。
- B 拿了资源 2，等着资源 1。
- 结果：**互相等待，永无出头之日**。这就是死锁。

## 第一部分：死锁原理 (Principles of Deadlock)

*对应课件 Page 3-18*

### 1. 什么是死锁？

- **定义**：一组进程中，每个进程都在等待只有该组中其他进程才能引发的事件。导致这组进程**永久阻塞 (Permanent Blocking)**。
- **资源类型**：
  - **可重用资源 (Reusable Resources)**：用完还回去的（CPU, 内存, 打印机, 信号量）。死锁通常发生在争夺这些资源时。
  - **可消耗资源 (Consumable Resources)**：用完就没了的（中断, 信号, 消息）。如果消息丢了也可能导致死锁。

### 2. 资源分配图 (Resource Allocation Graphs)

- 画圈代表进程，画方框代表资源。
- 箭头 P -> R：请求资源（Request）。
- 箭头 R -> P：持有资源（Assignment）。
- **关键点**：如果图中出现了**环路 (Cycle)**，就**可能**发生了死锁（如果每个资源只有一个实例，那就是**一定**死锁）。

### 3. 死锁的四个必要条件 (Conditions for Deadlock) 🔥🔥🔥 必背！

死锁发生，**必须同时**满足这四个条件（缺一不可）：

1. **互斥 (Mutual Exclusion)**：资源是独占的（一次只能一人用）。
2. **占有且等待 (Hold and Wait)**：我手里拿着一个资源，还要去申请别的资源。
3. **不可抢占 (No Preemption)**：别人手里的资源，我不能强行抢过来，只能等他自愿释放。
4. **循环等待 (Circular Wait)**：A等B，B等C... C等A，形成一个圈。

## 第二部分：处理死锁的三大策略

我们有三种办法对付死锁，程度由严到宽：

### 策略一：死锁预防 (Deadlock Prevention)

*对应课件 Page 19-24*

- **思路**：**破坏四个必要条件中的一个**，让死锁根本**不可能**发生。这是一个**静态**策略，很严格。
  - **破坏互斥**：不可能（有些资源如打印机必须互斥）。
  - **破坏占有且等待**：要求进程**一次性申请所有资源**。要到了就开始跑，要不到就等着。（缺点：太浪费，效率低）。
  - **破坏不可抢占**：如果申请不到新资源，就把手里的旧资源**主动释放**。（缺点：有些资源如打印机，做了一半不能停）。
  - **破坏循环等待**：给所有资源**编号**，要求大家必须**按顺序申请**（只能先申请1号再申请2号）。（缺点：编程麻烦）。

### 策略二：死锁避免 (Deadlock Avoidance) 🔥 计算题考点

*对应课件 Page 25-33*

- **思路**：允许那四个条件存在，但在**分配资源之前**，先算一算：**“如果我把这个资源给你，系统会不会有危险？”** 如果危险，就不给你。
- **状态定义**：
  - **安全状态 (Safe State)**：存在至少一种顺序（安全序列），能让所有进程都顺利执行完。
  - **不安全状态 (Unsafe State)**：找不到这样的顺序。**死锁必然发生在不安全状态，但不安全不代表立刻死锁。**
- **核心算法：银行家算法 (Banker's Algorithm)**
  - **逻辑**：你有 Need（还需多少），我有 Available（手头还剩多少）。
  - 只要 `Available >= Need`，我就能满足你，让你跑完，然后你把手里的资源全还给我（`Available` 变大），我再救下一个人。
  - 如果能把所有人都救活，就是**安全**的。

### 策略三：死锁检测 (Deadlock Detection)

*对应课件 Page 34-37*

- **思路**：不管那么多，随便分配。但OS会定期运行一个检测程序，看看有没有环路。
- **如果发现了死锁怎么办？(Recovery)**
  - 杀掉所有死锁进程（简单粗暴）。
  - 杀掉一个进程，看看解开了没（逐个击破）。
  - 抢占资源（回滚进程）。

## 第三部分：哲学家就餐问题 (Dining Philosophers Problem)

*对应课件 Page 38-40*

这是一个经典的死锁演示案例。

- **场景**：5个哲学家，5根筷子（Fork）。每人左右各一根。
- **规则**：想吃饭必须同时拿起左右两根筷子。
- **死锁场景**：所有人同时拿起左手的筷子。大家都在等右手的筷子，但右手的筷子在邻居手里。
- **解决方案**：
  1. **信号量**：限制最多只有4个人同时上桌（保证至少有一人能拿到两根）。
  2. **管程 (Monitor)**：把“拿两根筷子”作为一个原子操作。

## 📝 必背英文术语表 (Exam Vocabulary)

| **英文**                | **中文**   | **核心含义**          |
| ----------------------- | ---------- | --------------------- |
| **Deadlock**            | 死锁       | 永久阻塞              |
| **Reusable Resource**   | 可重用资源 | 用完归还（CPU/内存）  |
| **Consumable Resource** | 可消耗资源 | 用完消失（消息/中断） |
| **Hold and Wait**       | 占有且等待 | 吃着碗里看着锅里      |
| **No Preemption**       | 不可抢占   | 不能抢别人手里的      |
| **Circular Wait**       | 循环等待   | 形成等待环路          |
| **Deadlock Prevention** | 死锁预防   | 静态策略，破坏4条件   |
| **Deadlock Avoidance**  | 死锁避免   | 动态策略，银行家算法  |
| **Safe State**          | 安全状态   | 至少有一个安全序列    |
| **Banker's Algorithm**  | 银行家算法 | 避免死锁的核心算法    |
| **Dining Philosophers** | 哲学家就餐 | 经典并发问题          |

## 💡 常见简答与计算题思路

1. **“死锁预防”和“死锁避免”有什么区别？**
   - **预防 (Prevention)** 是立规矩（比如必须按顺序申请），限制比较死，资源利用率低，但绝对安全。
   - **避免 (Avoidance)** 是动态判断，允许你随意申请，但我审批时会算账（银行家算法），资源利用率高，但计算开销大。
2. **银行家算法计算步骤（简版）：**
   - `Need[i] = Max[i] - Allocation[i]` （算出每个人还缺多少）
   - 找一个进程 P，满足 `Need[P] <= Available` （找一个能救活的）
   - 假设 P 执行完，释放资源：`Available = Available + Allocation[P]`
   - 重复上述步骤。如果所有 P 都能被加入列表，系统就是**安全**的。
3. **死锁的四个必要条件是什么？如何破坏“循环等待”？**
   - 互斥、占有且等待、不可抢占、循环等待。
   - 破坏循环等待：对所有资源进行线性排序（编号），强制进程必须按编号递增的顺序申请资源。
# 👻 操作系统第8章：虚拟内存 (Virtual Memory)

## 🌟 核心逻辑：空手套白狼

虚拟内存的核心思想是：**“用到了再加载，没用到就丢在硬盘上”**。

- **局部性原理 (Principle of Locality)** 是这一切能成立的根本原因。
  - 进程在一段时间内，只会频繁访问一小部分代码和数据（热点）。
  - 所以，OS 只需要把这“一小部分”放在物理内存里，进程就能跑得很欢。剩下的扔在硬盘上，等需要的时候再换进来。

## 第一部分：硬件支持 (Hardware and Control Structures)

*对应课件 Page 3-23*

要想实现虚拟内存，光靠软件不行，必须有硬件（MMU）配合。

### 1. 分页与页表 (Paging & Page Table)

- **P bit (Present bit / Valid bit)**：页表项里多了一个位。
  - **1**：表示该页在**内存**里（可以直接读写）。
  - **0**：表示该页在**硬盘**上（发生**缺页中断 Page Fault**，需要 OS 去硬盘把它捞回来）。
- **M bit (Modify bit / Dirty bit)**：
  - **1**：表示该页被修改过。如果要把这页踢出内存，必须把它**写回硬盘**。
  - **0**：没改过。踢出内存时直接覆盖就行，不用写回（省IO）。

### 2. TLB (Translation Lookaside Buffer) 🔥 必考

- **是什么**：一个超级快的小缓存，装在 CPU 里。
- **干什么**：存最近用过的 `Page Number -> Frame Number` 映射。
- **为什么**：查内存里的页表太慢了（要多访问一次内存）。每次查地址，先看 TLB 有没有（TLB Hit），没有再去查内存页表（TLB Miss）。

### 3. 页表结构 (Page Table Structure)

- **多级页表 (Hierarchical Page Table)**：如果不分级，页表本身会大到内存装不下。分级后，页表也可以只加载一部分。
- **倒排页表 (Inverted Page Table)**：按物理内存块（Frame）来建表，而不是按逻辑页。适合 64 位这种超大地址空间的系统。

## 第二部分：OS 的策略 (Operating System Software)

*对应课件 Page 29-65*

这是本章的**重头戏**，OS 必须做出明智的决定。

### 1. 读取策略 (Fetch Policy)

- **请求分页 (Demand Paging)**：**“不见兔子不撒鹰”**。进程刚启动时，内存里啥也没有。执行第一条指令 -> 缺页 -> 载入 -> 执行 -> 又缺页... 慢慢把需要的页搬进来。
- **预调页 (Prepaging)**：猜你可能要用这一堆，一次性全读进来（比如利用磁盘连续读取特性）。

### 2. 置换策略 (Replacement Policy) 🔥🔥🔥 计算题重灾区

**问题**：内存满了，又要读新页进来，踢谁出去？

- **OPT (Optimal, 最佳)**：
  - **规则**：踢掉**未来最长时间内不再被访问**的那一页。
  - **地位**：理论上的上帝视角，**无法实现**（因为不知道未来发什么），但用来作为评价其他算法的标准。
- **LRU (Least Recently Used, 最近最少使用)**：
  - **规则**：踢掉**最近最久没用过**的那一页。（假设过去没用的，未来也没用）。
  - **地位**：性能最接近 OPT，但硬件实现很难（要记录每页的时间戳或维护栈）。
- **FIFO (First-In-First-Out, 先进先出)**：
  - **规则**：谁先来的踢谁。
  - **缺点**：**Belady现象**（给的内存多了，缺页率反而高了）。因为最早进来的可能是常用核心代码。
- **Clock (时钟算法 / Second Chance)**：
  - **规则**：给每页一个 Use Bit（访问位）。
  - 像时钟一样转圈扫描。
  - 如果指到的页 Use Bit = 1，给个机会（Second Chance），把它置 0，指针下移。
  - 如果指到的页 Use Bit = 0，**踢掉它**。
  - **地位**：LRU 的低成本近似实现，现代 OS 最常用。

### 3. 驻留集管理 (Resident Set Management)

- **分配给进程多少个物理块（Frame）？**
  - **固定分配 (Fixed Allocation)**：这就很死板。
  - **可变分配 (Variable Allocation)**：根据缺页率动态调整。缺页太频繁？多给你点内存。不怎么缺页？收回点内存。

## 第三部分：抖动 (Thrashing)

*对应课件 Page 61*

- **现象**：系统看起来在忙（CPU 利用率低，磁盘 IO 狂转），其实啥活也没干，光在**换页**了。
- **原因**：跑的进程太多（Multiprogramming level 太高），每个进程分到的内存都不够用（小于它的工作集 Working Set），导致大家都在排队读硬盘。
- **解决**：挂起几个进程，把它们的内存腾出来给别人。

## 📝 必背英文术语表 (Exam Vocabulary)

| **英文**                  | **中文**     | **核心含义**                   |
| ------------------------- | ------------ | ------------------------------ |
| **Virtual Memory**        | 虚拟内存     | 逻辑大内存，物理小内存         |
| **Principle of Locality** | 局部性原理   | VM 成功的基石                  |
| **Page Fault**            | 缺页中断     | 访问的页不在内存中             |
| **TLB**                   | 快表         | 页表的告诉缓存                 |
| **Inverted Page Table**   | 倒排页表     | 针对大地址空间优化             |
| **Demand Paging**         | 请求分页     | 用到了再调入                   |
| **Replacement Policy**    | 置换策略     | 内存满了踢谁                   |
| **LRU**                   | 最近最少使用 | 性能好，难实现                 |
| **Clock Policy**          | 时钟算法     | LRU 的实用版                   |
| **Thrashing**             | 抖动/颠簸    | 频繁换页导致系统瘫痪           |
| **Working Set**           | 工作集       | 进程某段时间内频繁访问的页集合 |

## 💡 计算题解题技巧：置换算法

**题目通常是**：给一个页框数（比如 3）和一个访问序列 `2, 3, 2, 1, 5, 2, 4...`，问发生几次缺页？

1. **画表格**：
   - 横轴：访问序列。
   - 纵轴：内存里的 3 个坑位。
2. **模拟过程**：
   - **FIFO**：先进来的在最上面，满了就把最上面的挤走。
   - **LRU**：**关键技巧** —— 每次命中（Hit）一个页，就把这个页**提到最新位置**（或者把它的计时清零）。踢人的时候，踢那个**“最老没动过”**的。
   - **Clock**：画个圈，标上 0/1 慢慢转。

**易错点**：

- 刚开始内存是空的，前几次装入虽然没满，但也算**缺页 (Page Fault)**！
- 有时候题目问的是“置换次数”而不是“缺页次数”。（缺页次数 = 刚开始装入次数 + 后来置换次数）。一定要看清题目！
## 一、章节概述

第二章主要介绍Intel 64和IA-32架构的系统级架构，包括处理器的操作模式、系统寄存器、数据结构以及系统指令。

## 二、处理器操作模式

### 2.1 IA-32架构的传统模式

1. **实模式（Real Mode）**
   - 提供Intel 8086处理器的编程环境
   - 处理器上电或复位后进入此模式

2. **保护模式（Protected Mode）**
   - 处理器的原生操作模式
   - 提供丰富的架构特性和高性能
   - 通过设置CR0寄存器的PE标志进入

3. **虚拟8086模式（Virtual-8086 Mode）**
   - 在保护模式下运行8086软件
   - 通过EFLAGS寄存器的VM标志控制

4. **系统管理模式（SMM）**
   - 用于电源管理和OEM功能
   - 通过SMI中断进入

### 2.2 Intel 64架构的IA-32e模式

**IA-32e模式包含两个子模式：**

1. **64位模式（64-bit Mode）**
   - 支持64位操作系统和应用程序
   - 提供64位线性地址
   - 支持大于64GB的物理地址空间

2. **兼容模式（Compatibility Mode）**
   - 允许运行大多数传统保护模式软件
   - 与64位应用程序共存于64位操作系统下

## 三、系统级架构组件

### 3.1 全局和本地描述符表（GDT/LDT）

**全局描述符表（GDT）**
- 包含段描述符，提供段的基地址、访问权限、类型和使用信息
- GDTR寄存器存储GDT的基地址和限长
- 32位模式下基地址为32位，IA-32e模式下为64位

**本地描述符表（LDT）**
- 可选的段描述符表
- LDTR寄存器存储LDT的段选择子和段描述符
- 在64位模式下支持64位基地址

**段选择子**
- 提供GDT/LDT的索引
- 包含全局/本地标志
- 包含访问权限信息

### 3.2 系统段、段描述符和门

**系统段类型：**
1. 任务状态段（TSS）
2. 本地描述符表（LDT）

**门描述符类型：**
1. **调用门（Call Gates）**
   - 提供对不同特权级代码段的受保护访问
   - 在64位模式和兼容模式之间转换

2. **中断门（Interrupt Gates）**
   - 用于中断处理
   - IA-32e模式下扩展为16字节

3. **陷阱门（Trap Gates）**
   - 用于异常处理

4. **任务门（Task Gates）**
   - IA-32e模式不支持

### 3.3 任务状态段（TSS）

**TSS的主要功能：**
- 定义任务的执行环境状态
- 存储通用寄存器、段寄存器的值
- 存储EFLAGS、EIP寄存器的值
- 包含三个特权级的栈段选择子和栈指针
- 包含与任务关联的LDT段选择子
- 包含分页结构层次的基地址

**任务切换过程：**
1. 保存当前任务状态到当前TSS
2. 加载新任务的TSS段选择子到任务寄存器
3. 通过GDT访问新TSS
4. 从新TSS加载处理器状态
5. 开始执行新任务

**IA-32e模式下的TSS：**
- 不支持硬件任务切换
- TSS继续存在，存储64位操作的重要信息：
  - 每个特权级的栈指针地址
  - 中断栈表的指针地址
  - IO权限位图的偏移地址

### 3.4 中断和异常处理

**中断描述符表（IDT）**
- 存储中断和异常处理程序的门描述符
- IDTR寄存器包含IDT的基地址和限长
- 在IA-32e模式下，中断描述符扩展为16字节

**中断处理流程：**
1. 接收中断向量（中断号）
2. 使用中断向量作为IDT索引
3. 根据门描述符类型访问处理程序：
   - 中断门/陷阱门：直接访问处理程序
   - 任务门（仅32位）：通过任务切换访问

## 四、内存管理

### 4.1 分段机制

**访问段中字节的步骤：**
1. 提供段选择子和偏移量
2. 段选择子访问GDT/LDT中的段描述符
3. 从段描述符获取线性地址空间的基地址
4. 偏移量提供相对基地址的位置

**特权级检查：**
- 当前特权级（CPL）
- 段描述符特权级（DPL）
- 请求特权级（RPL）

### 4.2 分页机制

**32位分页：**
- 两级分页结构：页目录和页表
- CR3寄存器包含页目录基地址
- 支持4KB页面
- PSE标志启用时支持4MB页面

**PAE分页（物理地址扩展）：**
- 三级结构：页目录指针表、页目录、页表
- 支持超过32位的物理地址
- 进入IA-32e模式前必须设置PAE

**IA-32e模式分页：**
- 四级分页结构：
  1. PML4（Page Map Level 4）
  2. 页目录指针表
  3. 页目录
  4. 页表
- CR3存储PML4的基地址
- 支持64位线性地址

**内存类型控制：**
- PCD（Page-level Cache Disable）标志
- PWT（Page-level Write-Through）标志

## 五、系统寄存器

### 5.1 EFLAGS/RFLAGS寄存器

**系统标志位：**

1. **TF（Trap Flag，位8）**
   - 设置：启用单步调试模式
   - 清除：禁用单步模式

2. **IF（Interrupt Enable，位9）**
   - 控制可屏蔽硬件中断的响应
   - 受CPL、IOPL和VME标志影响

3. **IOPL（I/O Privilege Level，位12-13）**
   - 指示当前程序或任务的I/O特权级
   - 只能在CPL=0时通过POPF和IRET修改

4. **NT（Nested Task，位14）**
   - 控制中断和调用任务的链接
   - 任务调用时由处理器设置

5. **RF（Resume Flag，位16）**
   - 临时禁用指令断点的调试异常

6. **VM（Virtual-8086 Mode，位17）**
   - 设置：启用虚拟8086模式
   - 清除：返回保护模式
   - IA-32e模式不支持

7. **AC（Alignment Check，位18）**
   - 与CR0.AM配合启用对齐检查
   - 仅在CPL=3时有效

8. **VIF（Virtual Interrupt Flag，位19）**
   - IF标志的虚拟映像
   - 与VIP标志配合使用

9. **VIP（Virtual Interrupt Pending，位20）**
   - 软件设置表示中断挂起

10. **ID（Identification，位21）**
    - 指示对CPUID指令的支持

### 5.2 内存管理寄存器

**GDTR（全局描述符表寄存器）**
- 存储GDT的基地址和限长
- 保护模式：32位基地址
- IA-32e模式：64位基地址
- 指令：LGDT（加载）、SGDT（存储）

**LDTR（本地描述符表寄存器）**
- 存储LDT的段选择子、基地址、段限长和描述符属性
- 指令：LLDT（加载）、SLDT（存储）
- 任务切换时自动加载

**IDTR（中断描述符表寄存器）**
- 存储IDT的基地址和限长
- 指令：LIDT（加载）、SIDT（存储）

**TR（任务寄存器）**
- 存储当前任务TSS的段选择子、基地址、段限长和描述符属性
- 指令：LTR（加载）、STR（存储）
- 任务切换时自动加载

### 5.3 控制寄存器（CR0-CR4, CR8）

重要控制寄存器的结构：
![[Pasted image 20251104152108.png]]


**CR0寄存器重要标志：**

1. **PE（Protection Enable，位0）**
   - 启用保护模式
   - 与PG配合控制分页

2. **MP（Monitor Coprocessor，位1）**
   - 控制WAIT指令与TS标志的交互

3. **EM（Emulation，位2）**
   - 指示处理器无内部/外部x87 FPU
   - 影响MMX/SSE指令执行

4. **TS（Task Switched，位3）**
   - 每次任务切换时设置
   - 延迟保存x87 FPU/MMX/SSE上下文

5. **ET（Extension Type，位4）**
   - Pentium 4及以后固定为1

6. **NE（Numeric Error，位5）**
   - 启用x87 FPU错误的原生报告机制

7. **WP（Write Protect，位16）**
   - 禁止超级用户写只读页面

8. **AM（Alignment Mask，位18）**
   - 与EFLAGS.AC配合启用对齐检查

9. **NW（Not Write-through，位29）**
   - 与CD配合控制缓存策略

10. **CD（Cache Disable，位30）**
    - 禁用缓存

11. **PG（Paging，位31）**
    - 启用分页
    - 必须在PE=1时才能设置

**CR2寄存器：**
- 存储导致页错误的线性地址

**CR3寄存器：**
- 存储分页结构层次的物理基地址
- PCD和PWT标志控制缓存
- 32位分页：页目录基地址
- PAE分页：页目录指针表基地址
- IA-32e模式：PML4表基地址

**CR4寄存器重要标志：**

1. **VME（Virtual-8086 Mode Extensions，位0）**
   - 启用虚拟8086模式扩展

2. **PVI（Protected-Mode Virtual Interrupts，位1）**
   - 启用保护模式虚拟中断

3. **TSD（Time Stamp Disable，位2）**
   - 限制RDTSC指令在CPL=0执行

4. **DE（Debugging Extensions，位3）**
   - 引用DR4和DR5产生#UD异常

5. **PSE（Page Size Extensions，位4）**
   - 32位分页时启用4MB页面

6. **PAE（Physical Address Extension，位5）**
   - 启用超过32位的物理地址
   - 进入IA-32e模式前必须设置

7. **MCE（Machine-Check Enable，位6）**
   - 启用机器检查异常

8. **PGE（Page Global Enable，位7）**
   - 启用全局页面特性
   - 全局页面不会从TLB刷新

9. **PCE（Performance-Monitoring Counter Enable，位8）**
   - 允许任意特权级执行RDPMC

10. **OSFXSR（位9）**
    - 操作系统支持FXSAVE/FXRSTOR
    - 启用SSE/SSE2/SSE3/SSSE3/SSE4指令

11. **OSXMMEXCPT（位10）**
    - 操作系统支持未屏蔽SIMD浮点异常

12. **VMXE（位13）**
    - 启用VMX操作

13. **SMXE（位14）**
    - 启用SMX操作

14. **FSGSBASE（位16）**
    - 启用FS/GS基地址访问指令

15. **PCIDE（位17）**
    - 启用进程上下文标识符（PCID）
    - 仅在IA-32e模式下可设置

16. **OSXSAVE（位18）**
    - 启用XSAVE及处理器扩展状态
    - 使能XGETBV/XSETBV指令

17. **SMEP（位20）**
    - 启用超级用户模式执行保护

**CR8寄存器（仅64位模式）：**
- TPL（Task Priority Level，位0-3）
- 控制允许中断处理器的最高优先级
- 值为0：所有中断启用
- 值为15：所有中断禁用

### 5.4 扩展控制寄存器（XCR0）

扩展控制寄存器结构图：
![[Pasted image 20251104152244.png]]


**XCR0（扩展特性启用寄存器）**
- 需要CPUID.01H:ECX.XSAVE\[26\]=1
- 只有CR4.OSXSAVE=1时才能访问
- 使用XSETBV指令设置，XGETBV指令读取

**XCR0定义的处理器状态：**

1. **X87（位0）**
   - 必须为1
   - 尝试写0会产生#GP异常

2. **SSE（位1）**
   - 启用XSAVE/XRSTOR管理MXCSR和XMM寄存器

3. **AVX（位2）**
   - 启用AVX指令
   - 启用XSAVE/XRSTOR管理YMM寄存器高半部分

**使用规则：**
- 位0必须为1
- 位1=0且位2=1会产生#GP异常
- 复位后除位0外所有位清零

## 六、系统指令

### 6.1 加载和存储系统寄存器

**描述符表寄存器操作：**
- LGDT/SGDT：加载/存储GDTR
- LIDT/SIDT：加载/存储IDTR
- LLDT/SLDT：加载/存储LDTR
- LTR/STR：加载/存储TR

**控制寄存器操作：**
- MOV CRn：加载和存储控制寄存器
- LMSW/SMSW：加载/存储机器状态字（CR0的位0-15）
- CLTS：清除CR0中的TS标志

### 6.2 访问权限验证指令

1. **ARPL（Adjust RPL）**
   - 调整段选择子的RPL匹配提供者
   - 64位模式不支持

2. **LAR（Load Access Rights）**
   - 验证段的可访问性
   - 加载访问权限信息到通用寄存器

3. **LSL（Load Segment Limit）**
   - 验证段的可访问性
   - 加载段限长到通用寄存器

4. **VERR/VERW（Verify for Reading/Writing）**
   - 验证段在给定CPL下是否可读/可写

### 6.3 调试和性能监控

**调试寄存器：**
- MOV DRn：加载和存储调试寄存器DR0-DR7
- 64位模式下调试寄存器为64位

**性能计数器：**
- RDPMC：读取性能监控计数器
- 支持40位计数器（NetBurst微架构18个，P6系列2个）
- Intel Core微架构支持可编程和固定功能计数器

**时间戳计数器：**
- RDTSC：读取64位时间戳计数器
- RDTSCP：读取序列化时间戳计数器
- 每次处理器复位时重置为0

### 6.4 缓存和TLB管理

1. **INVD（Invalidate Cache）**
   - 无回写的缓存无效化
   - 向外部缓存发送无效化信号

2. **WBINVD（Write Back and Invalidate）**
   - 回写并无效化缓存
   - 写回修改的缓存行到内存
   - 对共享缓存层次结构的影响：
     - 回写并无效化共享缓存
     - 不影响非共享缓存

3. **INVLPG（Invalidate TLB Entry）**
   - 无效化指定页面的TLB条目

### 6.5 处理器控制

1. **HLT（Halt）**
   - 停止处理器直到接收到中断
   - 生成特殊总线周期

2. **LOCK前缀**
   - 调用锁定的读-修改-写操作
   - Pentium 4及以后：缓存锁或总线锁
   - 早期处理器：总线锁

3. **RSM（Resume from SMM）**
   - 从系统管理模式返回

### 6.6 模型特定寄存器

**MSR访问：**
- RDMSR：读取MSR
- WRMSR：写入MSR
- ECX指定MSR地址
- 64位模式下MSR地址为32位

### 6.7 处理器扩展状态

**XGETBV/XSETBV：**
- XGETBV：返回XCR0的状态
- XSETBV：启用处理器扩展状态
- 需要CR4.OSXSAVE=1

## 七、IA-32e模式特性总结

### 7.1 64位模式特性

1. **寄存器扩展**
   - 控制寄存器CR0-CR4扩展到64位
   - CR8可用于任务优先级控制
   - RFLAGS扩展到64位
   - 调试寄存器DR0-DR7为64位

2. **描述符和表**
   - GDTR、LDTR、IDTR、TR支持64位基地址
   - LDT描述符、TSS描述符扩展到16字节
   - 调用门、中断门、陷阱门为16字节

3. **分页**
   - 四级分页结构
   - 支持64位线性地址
   - CR3存储PML4基地址

4. **不支持的特性**
   - 不支持任务门
   - 不支持硬件任务切换
   - VM标志不能设置（不支持虚拟8086模式）
   - 特权级变化时栈段选择子设为NULL

### 7.2 兼容模式特性

1. **向后兼容**
   - 运行大多数传统32位代码
   - 与64位应用程序共存
   - 描述符不扩展

2. **限制**
   - 不支持硬件任务切换
   - 64位模式和兼容模式通过调用门转换

### 7.3 回顾总体架构
![[Pasted image 20251104145942.png]]
**一、左侧：系统寄存器组**
1. EFLAGS寄存器
  - **位置**：图的左上角
  - **作用**：包含系统标志位，控制处理器行为
  - **关键标志**：IF（中断使能）、IOPL（I/O特权级）、VM（虚拟8086模式）等

2. 控制寄存器（CR0-CR4）
  CR0 - 系统控制标志（PE、PG、WP等）
  CR1 - 保留
  CR2 - 页错误线性地址
  CR3 - 分页结构基地址（PDBR）
  CR4 - 架构扩展控制（PAE、PSE、PGE等）
  
3. 任务寄存器（Task Register）
- 存储当前任务TSS的段选择子
- 指向GDT中的TSS描述符

4. 中断向量（Interrupt Vector）
  - 中断号/异常号
  - 用作IDT的索引

5. IDTR（中断描述符表寄存器）
  - 存储IDT的基地址和限长

6. XCR0（XFEM）
  - 扩展特性启用寄存器
  - 控制处理器扩展状态（x87、SSE、AVX等）

  

  **二、中间：描述符表结构**
1. 全局描述符表（GDT）
  **结构层次**：
  GDTR → GDT → 各种描述符
                ├─ 段描述符（Seg. Desc.）
                ├─ TSS描述符（TSS Desc.）
                ├─ LDT描述符（LDT Desc.）
                └─ 调用门（Call Gate）
  **关键连接**：
  - **Segment Selector（段选择子）** → 索引到具体的段描述符
  - **TSS Seg. Sel.** → 索引到TSS描述符
  - **实线箭头**：表示线性地址
  - **虚线箭头**：表示段选择子
  - **点线箭头**：表示物理地址

2. 中断描述符表（IDT）
  **包含三种门描述符**：
  IDT
  ├─ 中断门（Interrupt Gate）
  ├─ 陷阱门（Trap Gate）
  └─ 任务门（Task Gate）

3. 本地描述符表（LDT）
  - 通过LDTR寄存器访问
  - LDT本身在GDT中有描述符
  - 包含任务专用的段描述符

  **三、右侧：任务和处理程序结构**
1. 任务结构（Task）
  任务状态段（TSS）
  ├─ Code（代码段）
  ├─ Data（数据段）
  └─ Stack（栈段）

  **三种任务状态**：
  - **Current TSS**：当前正在执行的任务
  - **Task-State Segment (TSS)**：待切换的任务
  - 通过TSS描述符连接

2. 处理程序类型
  **a) 中断处理程序（Interrupt Handler）**
  Current TSS → Code
             → Stack
  - 处理外部硬件中断
  - 保持在当前任务上下文
  **b) 异常处理程序（Exception Handler）**
  Current TSS → Code
             → Stack
  - 处理处理器异常（#GP、#PF等）
  - 可能涉及特权级切换
  **c) 受保护过程（Protected Procedure）**
  通过调用门访问
  Current TSS → Code
             → Stack
  - 跨特权级的过程调用
  - 通过Call Gate实现访问控制

  **四、底部：分页机制**

地址转换流程（32位分页）
  线性地址（Linear Address）
        ↓
  分解为：Dir | Table | Offset
        ↓
  CR3* → 页目录（Page Directory）
        ↓
  页目录项（Pg. Dir. Entry） → 页表（Page Table）
        ↓
  页表项（Pg. Tbl. Entry） → 页（Page）
        ↓
  物理地址（Physical Addr.）
  
| 符号       | 含义        |
|----------|-----------|
| 实线箭头（→）  | 线性地址或直接指向 |
| 虚线箭头（⇢）  | 段选择子引用    |
| 点线箭头（⋯→） | 物理地址      |
| 矩形框      | 寄存器或数据结构  |
| 双线矩形     | 描述符表寄存器   |

## 八、关键概念总结

### 8.1 特权级保护

**四个特权级（0-3）：**
- 级别0：最高特权（操作系统内核）
- 级别1-2：系统服务
- 级别3：应用程序

**特权级检查：**
- CPL：当前代码段的特权级
- DPL：目标段的特权级
- RPL：段选择子中的请求特权级

### 8.2 任务管理

**任务切换方法：**
1. 通过CALL/JMP到TSS
2. 通过CALL/JMP到任务门
3. 通过中断/异常到任务门

**任务切换步骤：**
1. 保存当前任务状态
2. 加载新任务TSS选择子
3. 访问新TSS
4. 加载新任务状态
5. 执行新任务

### 8.3 中断和异常

**中断源：**
1. 外部硬件中断（通过INTR引脚）
2. 软件中断（INT n指令）
3. 处理器异常

**处理机制：**
- 通过IDT访问处理程序
- 可能涉及特权级转换
- 可能涉及栈切换

### 8.4 内存保护

**分段保护：**
- 段限长检查
- 类型检查
- 特权级检查

**分页保护：**
- 读/写权限
- 用户/超级用户权限
- 执行禁止（XD位）
- SMEP保护

## 读书心得

第二章作为 Intel 64 和 IA-32 架构系统编程的 “入门向导”，没有深陷复杂的指令细节，而是从宏观视角搭建起了处理器系统级架构的核心框架，让我对底层编程的 “底层逻辑” 有了更清晰的认知，尤其感受到 Intel 架构设计中 “兼容性与扩展性兼顾” 的核心思想。

这一章最核心的价值，是梳理清楚了 Intel 处理器的 “系统级组件图谱”—— 从全局 / 局部描述符表（GDT/LDT）、系统段与门（调用门、任务门等），到任务状态段（TSS）、中断异常处理机制和内存管理架构，这些看似独立的组件被串联成一个有机整体，让我明白系统编程的本质的是 “通过规范这些组件的交互，实现对处理器资源的有序管控”。比如，之前对 “段描述符” 的理解仅停留在 “地址转换工具”，但本章明确了其同时承载 “权限控制”“段类型标识” 等多重功能，是连接内存访问与系统保护的关键枢纽。

操作模式的讲解是本章的亮点。从实地址模式、保护模式到 IA-32e 模式的演进脉络，清晰展现了 Intel 架构从 16 位到 64 位的兼容式升级思路 —— 不是推翻旧架构重建，而是在保留 legacy 模式支持的基础上，通过扩展寄存器（如 IA32_EFER）、优化段页机制实现功能升级。尤其是 IA-32e 模式下 “64 位操作 + 兼容性模式” 的设计，既满足了现代软件对大地址空间的需求，又保障了旧有 32 位程序的平稳运行，这种 “向前兼容” 的设计哲学，正是 Intel 架构能长期占据市场主流的重要原因之一。

系统寄存器和系统指令的汇总部分，则为后续深入编程提供了 “工具清单”。之前零散接触过的 CR0-CR4 控制寄存器、GDTR/IDTR 描述符表寄存器，在本章中被系统归类，并明确了各自的核心作用（如 CR0.PE 位开启保护模式、CR4.PAE 位扩展物理地址空间），让我意识到这些寄存器是 “切换处理器工作状态的总开关”，任何系统级功能的启用（如分页、虚拟化），本质上都是对这些寄存器的精准配置。

